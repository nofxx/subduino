#!/usr/bin/env ruby
require 'serialport'
#require 'eventmachine'
require 'redis'
require 'stringio'
require 'readline'
require 'logger'

# def halt!
#   puts "Closing server"
#   @redis.quit
#   puts "..."
#   exit
# end

Thread.current.abort_on_exception = false

# trap(:TERM) { halt! }
# trap(:INT)  { halt! }

LOG = Logger.new("out.log")
BAUDS = 115200
#BAUDS = 9600
DATA_BITS = 8
DATA_STOP = 1
parity = SerialPort::NONE

def log(txt, type="info")
  LOG.send(type, txt)
end

@qi, @qo = Queue.new, Queue.new
@redis = Redis.new(:timeout => 0)
@sp = SerialPort.new("/dev/ttyUSB0", BAUDS) #, DATA_BITS, DATA_STOP, parity)
# @sp.read_timeout = 10;# @sp.write_timeout = 10


log "[USB] Starting USB Connect..." + @sp.get_modem_params.map { |k,v| "#{k}: #{v}" }.join(" ")
log "[USB] Read Timeout #{@sp.read_timeout}" # {@sp.write_timeout}"

#
# Read I/O
#
Thread.new do
  Thread.current.abort_on_exception = false
  icache = []

  loop do
    begin
      if char = @sp.getc

        if char !~ /\n|\r/
          icache << char
         # p icache
        else
          data = icache.join(""); icache = []
          if data =~ /:/
            #  log "[COMM] #{data.sub(/\n|\r/, '')}"
            read = []
            log "[INPUT] --------------- #{Time.now.to_i}"
            data.split(",").each do |d|
              comm, value = d.split(":")
              read << case comm
              when "TEMP"  then  "%0.2f C" % (value.to_i * 0.04)
              when "LIGHT" then  "#{value.to_i * 2} Lux"
              else
                 "#{comm}: #{value}"
              end
            end
            log "[SENSOR] " + read.join(", ")
          else
            log "[INPUT] Done."
          end
        end
      end
    rescue => e
      puts "ERRRRR #{e}"
    end
  end
end

#
# Read PubSub
  #
  #EM.defer do
  Thread.new do
    @redis.subscribe('ard') do |on|
      on.subscribe {|klass, num_subs| log "[PubSub] Subscribed to #{klass} (#{num_subs} subscriptions)" }
      on.message do |klass, msg|
        log "[SUB] #{msg}"
        @qi << msg
        if msg == 'exit'
          @redis.unsubscribe
        end
      end
      on.unsubscribe {|klass, num_subs| log "[PubSub] Unsubscribed to #{klass} (#{num_subs} subscriptions)" }
    end
  end

  #
  # Write I/O/Pubsub
  #
  loop do
    if @qi.size > 0
      tx = @qi.pop
      log "[QUEUE IN] #{@qo.size} -> #{tx}"
      txt = tx.sub("\n", "\r")
      txt += "\r" unless txt =~ /\\r/
      @sp.write(txt)
    end
    if @qo.size > 0
      log "[QUEUE OUT] #{@qo.size}"
      # publish pubsub
    end
  end

  # open("/dev/tty", "r+") { |tty|
  #   tty.sync = true
  #   # Thread.new {
  #   #   while true do
  #   #     tty.printf("%c", sp.getc)
  #   #   end
  #   # }
  #   while (l = tty.gets) do
  #     @sp.write(l.sub("\n", "\r"))
  #   end
  # }
  log "Closing..."
  @sp.close


  # end

#end
